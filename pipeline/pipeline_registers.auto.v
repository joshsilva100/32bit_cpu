// Pipeline register 'if_id' automatically generated by generate_pipelines.py.
// Used to connect two stages of the pipeline together.
// A list of connected wires is available in generate_pipelines.py
// and the full diagram can be found in pipelined_machine.pdf.
//
// clk - Clock signal. Inputs copy to outputs on rising edge.
// reset - When high, sets all outputs to zeros. Asynchronous
// enable - When high, inputs are copied to outputs on clock edge. When low, outputs remain constant.
// flush - When high, all inputs are set to zero synchronously.
module if_id_reg(
    clk,
    reset,
    enable,
    flush,
	inst_IN,
	inst_OUT,
	link_alu_out_IN,
	link_alu_out_OUT,
	plus4_alu_out_IN,
	plus4_alu_out_OUT,
	alu_op_IN,
	alu_op_OUT,
	wr_enable_IN,
	wr_enable_OUT,
	itype_IN,
	itype_OUT,
	except_IN,
	except_OUT,
	control_type_IN,
	control_type_OUT,
	lui_IN,
	lui_OUT,
	slt_IN,
	slt_OUT,
	byte_load_IN,
	byte_load_OUT,
	word_we_IN,
	word_we_OUT,
	byte_we_IN,
	byte_we_OUT,
	mem_read_IN,
	mem_read_OUT,
	shift_v_IN,
	shift_v_OUT,
	shift_op_IN,
	shift_op_OUT,
	shift_IN,
	shift_OUT,
	load_ra_IN,
	load_ra_OUT,
	link_IN,
	link_OUT,
	alu_b_zero_IN,
	alu_b_zero_OUT,
	branch_control_IN,
	branch_control_OUT,
	jr_IN,
	jr_OUT
);

    input clk, reset, enable, flush;
    input [31:0] inst_IN;
    output reg [31:0] inst_OUT;
    input [31:0] link_alu_out_IN;
    output reg [31:0] link_alu_out_OUT;
    input [31:0] plus4_alu_out_IN;
    output reg [31:0] plus4_alu_out_OUT;
    input [2:0] alu_op_IN;
    output reg [2:0] alu_op_OUT;
    input wr_enable_IN;
    output reg wr_enable_OUT;
    input itype_IN;
    output reg itype_OUT;
    input except_IN;
    output reg except_OUT;
    input control_type_IN;
    output reg control_type_OUT;
    input lui_IN;
    output reg lui_OUT;
    input slt_IN;
    output reg slt_OUT;
    input byte_load_IN;
    output reg byte_load_OUT;
    input word_we_IN;
    output reg word_we_OUT;
    input byte_we_IN;
    output reg byte_we_OUT;
    input mem_read_IN;
    output reg mem_read_OUT;
    input shift_v_IN;
    output reg shift_v_OUT;
    input [1:0] shift_op_IN;
    output reg [1:0] shift_op_OUT;
    input shift_IN;
    output reg shift_OUT;
    input load_ra_IN;
    output reg load_ra_OUT;
    input link_IN;
    output reg link_OUT;
    input alu_b_zero_IN;
    output reg alu_b_zero_OUT;
    input [2:0] branch_control_IN;
    output reg [2:0] branch_control_OUT;
    input jr_IN;
    output reg jr_OUT;
    
    always @(posedge clk or posedge reset) begin
        // On reset, clear all registers to zero
        if (reset || flush) begin
            inst_OUT <= 32'd0;
            link_alu_out_OUT <= 32'd0;
            plus4_alu_out_OUT <= 32'd0;
            alu_op_OUT <= 3'd0;
            wr_enable_OUT <= 1'd0;
            itype_OUT <= 1'd0;
            except_OUT <= 1'd0;
            control_type_OUT <= 1'd0;
            lui_OUT <= 1'd0;
            slt_OUT <= 1'd0;
            byte_load_OUT <= 1'd0;
            word_we_OUT <= 1'd0;
            byte_we_OUT <= 1'd0;
            mem_read_OUT <= 1'd0;
            shift_v_OUT <= 1'd0;
            shift_op_OUT <= 2'd0;
            shift_OUT <= 1'd0;
            load_ra_OUT <= 1'd0;
            link_OUT <= 1'd0;
            alu_b_zero_OUT <= 1'd0;
            branch_control_OUT <= 3'd0;
            jr_OUT <= 1'd0;
        end

        // Normal Operation
        else if (enable) begin
            inst_OUT <= inst_IN;
            link_alu_out_OUT <= link_alu_out_IN;
            plus4_alu_out_OUT <= plus4_alu_out_IN;
            alu_op_OUT <= alu_op_IN;
            wr_enable_OUT <= wr_enable_IN;
            itype_OUT <= itype_IN;
            except_OUT <= except_IN;
            control_type_OUT <= control_type_IN;
            lui_OUT <= lui_IN;
            slt_OUT <= slt_IN;
            byte_load_OUT <= byte_load_IN;
            word_we_OUT <= word_we_IN;
            byte_we_OUT <= byte_we_IN;
            mem_read_OUT <= mem_read_IN;
            shift_v_OUT <= shift_v_IN;
            shift_op_OUT <= shift_op_IN;
            shift_OUT <= shift_IN;
            load_ra_OUT <= load_ra_IN;
            link_OUT <= link_IN;
            alu_b_zero_OUT <= alu_b_zero_IN;
            branch_control_OUT <= branch_control_IN;
            jr_OUT <= jr_IN;
        end 

        // Being stalled by Hazard Unit. Explicitly stating to hold previous values (Dr. Wei advice for if else statements)
        else begin 
            inst_OUT <= inst_OUT;
            link_alu_out_OUT <= link_alu_out_OUT;
            plus4_alu_out_OUT <= plus4_alu_out_OUT;
            alu_op_OUT <= alu_op_OUT;
            wr_enable_OUT <= wr_enable_OUT;
            itype_OUT <= itype_OUT;
            except_OUT <= except_OUT;
            control_type_OUT <= control_type_OUT;
            lui_OUT <= lui_OUT;
            slt_OUT <= slt_OUT;
            byte_load_OUT <= byte_load_OUT;
            word_we_OUT <= word_we_OUT;
            byte_we_OUT <= byte_we_OUT;
            mem_read_OUT <= mem_read_OUT;
            shift_v_OUT <= shift_v_OUT;
            shift_op_OUT <= shift_op_OUT;
            shift_OUT <= shift_OUT;
            load_ra_OUT <= load_ra_OUT;
            link_OUT <= link_OUT;
            alu_b_zero_OUT <= alu_b_zero_OUT;
            branch_control_OUT <= branch_control_OUT;
            jr_OUT <= jr_OUT;
        end
    end

endmodule

// Pipeline register 'id_ex' automatically generated by generate_pipelines.py.
// Used to connect two stages of the pipeline together.
// A list of connected wires is available in generate_pipelines.py
// and the full diagram can be found in pipelined_machine.pdf.
//
// clk - Clock signal. Inputs copy to outputs on rising edge.
// reset - When high, sets all outputs to zeros. Asynchronous
// enable - When high, inputs are copied to outputs on clock edge. When low, outputs remain constant.
// flush - When high, all inputs are set to zero synchronously.
module id_ex_reg(
    clk,
    reset,
    enable,
    flush,
	inst_IN,
	inst_OUT,
	rs_data_IN,
	rs_data_OUT,
	rt_data_IN,
	rt_data_OUT,
	link_alu_out_IN,
	link_alu_out_OUT,
	rs_num_IN,
	rs_num_OUT,
	rt_num_IN,
	rt_num_OUT,
	plus4_alu_out_IN,
	plus4_alu_out_OUT,
	alu_op_IN,
	alu_op_OUT,
	wr_enable_IN,
	wr_enable_OUT,
	itype_IN,
	itype_OUT,
	except_IN,
	except_OUT,
	control_type_IN,
	control_type_OUT,
	lui_IN,
	lui_OUT,
	slt_IN,
	slt_OUT,
	byte_load_IN,
	byte_load_OUT,
	word_we_IN,
	word_we_OUT,
	byte_we_IN,
	byte_we_OUT,
	mem_read_IN,
	mem_read_OUT,
	shift_v_IN,
	shift_v_OUT,
	shift_op_IN,
	shift_op_OUT,
	shift_IN,
	shift_OUT,
	load_ra_IN,
	load_ra_OUT,
	link_IN,
	link_OUT,
	alu_b_zero_IN,
	alu_b_zero_OUT,
	branch_control_IN,
	branch_control_OUT,
	jr_IN,
	jr_OUT
);

    input clk, reset, enable, flush;
    input [31:0] inst_IN;
    output reg [31:0] inst_OUT;
    input [31:0] rs_data_IN;
    output reg [31:0] rs_data_OUT;
    input [31:0] rt_data_IN;
    output reg [31:0] rt_data_OUT;
    input [31:0] link_alu_out_IN;
    output reg [31:0] link_alu_out_OUT;
    input [4:0] rs_num_IN;
    output reg [4:0] rs_num_OUT;
    input [4:0] rt_num_IN;
    output reg [4:0] rt_num_OUT;
    input [31:0] plus4_alu_out_IN;
    output reg [31:0] plus4_alu_out_OUT;
    input [2:0] alu_op_IN;
    output reg [2:0] alu_op_OUT;
    input wr_enable_IN;
    output reg wr_enable_OUT;
    input itype_IN;
    output reg itype_OUT;
    input except_IN;
    output reg except_OUT;
    input control_type_IN;
    output reg control_type_OUT;
    input lui_IN;
    output reg lui_OUT;
    input slt_IN;
    output reg slt_OUT;
    input byte_load_IN;
    output reg byte_load_OUT;
    input word_we_IN;
    output reg word_we_OUT;
    input byte_we_IN;
    output reg byte_we_OUT;
    input mem_read_IN;
    output reg mem_read_OUT;
    input shift_v_IN;
    output reg shift_v_OUT;
    input [1:0] shift_op_IN;
    output reg [1:0] shift_op_OUT;
    input shift_IN;
    output reg shift_OUT;
    input load_ra_IN;
    output reg load_ra_OUT;
    input link_IN;
    output reg link_OUT;
    input alu_b_zero_IN;
    output reg alu_b_zero_OUT;
    input [2:0] branch_control_IN;
    output reg [2:0] branch_control_OUT;
    input jr_IN;
    output reg jr_OUT;
    
    always @(posedge clk or posedge reset) begin
        // On reset, clear all registers to zero
        if (reset || flush) begin
            inst_OUT <= 32'd0;
            rs_data_OUT <= 32'd0;
            rt_data_OUT <= 32'd0;
            link_alu_out_OUT <= 32'd0;
            rs_num_OUT <= 5'd0;
            rt_num_OUT <= 5'd0;
            plus4_alu_out_OUT <= 32'd0;
            alu_op_OUT <= 3'd0;
            wr_enable_OUT <= 1'd0;
            itype_OUT <= 1'd0;
            except_OUT <= 1'd0;
            control_type_OUT <= 1'd0;
            lui_OUT <= 1'd0;
            slt_OUT <= 1'd0;
            byte_load_OUT <= 1'd0;
            word_we_OUT <= 1'd0;
            byte_we_OUT <= 1'd0;
            mem_read_OUT <= 1'd0;
            shift_v_OUT <= 1'd0;
            shift_op_OUT <= 2'd0;
            shift_OUT <= 1'd0;
            load_ra_OUT <= 1'd0;
            link_OUT <= 1'd0;
            alu_b_zero_OUT <= 1'd0;
            branch_control_OUT <= 3'd0;
            jr_OUT <= 1'd0;
        end

        else if (enable) begin
            inst_OUT <= inst_IN;
            rs_data_OUT <= rs_data_IN;
            rt_data_OUT <= rt_data_IN;
            link_alu_out_OUT <= link_alu_out_IN;
            rs_num_OUT <= rs_num_IN;
            rt_num_OUT <= rt_num_IN;
            plus4_alu_out_OUT <= plus4_alu_out_IN;
            alu_op_OUT <= alu_op_IN;
            wr_enable_OUT <= wr_enable_IN;
            itype_OUT <= itype_IN;
            except_OUT <= except_IN;
            control_type_OUT <= control_type_IN;
            lui_OUT <= lui_IN;
            slt_OUT <= slt_IN;
            byte_load_OUT <= byte_load_IN;
            word_we_OUT <= word_we_IN;
            byte_we_OUT <= byte_we_IN;
            mem_read_OUT <= mem_read_IN;
            shift_v_OUT <= shift_v_IN;
            shift_op_OUT <= shift_op_IN;
            shift_OUT <= shift_IN;
            load_ra_OUT <= load_ra_IN;
            link_OUT <= link_IN;
            alu_b_zero_OUT <= alu_b_zero_IN;
            branch_control_OUT <= branch_control_IN;
            jr_OUT <= jr_IN;
        end
    end

endmodule

// Pipeline register 'ex_mem' automatically generated by generate_pipelines.py.
// Used to connect two stages of the pipeline together.
// A list of connected wires is available in generate_pipelines.py
// and the full diagram can be found in pipelined_machine.pdf.
//
// clk - Clock signal. Inputs copy to outputs on rising edge.
// reset - When high, sets all outputs to zeros. Asynchronous
// enable - When high, inputs are copied to outputs on clock edge. When low, outputs remain constant.
// flush - When high, all inputs are set to zero synchronously.
module ex_mem_reg(
    clk,
    reset,
    enable,
    flush,
	alu_out_IN,
	alu_out_OUT,
	rt_data_IN,
	rt_data_OUT,
	rd_num_IN,
	rd_num_OUT,
	link_out_IN,
	link_out_OUT,
	rs_num_IN,
	rs_num_OUT,
	rt_num_IN,
	rt_num_OUT,
	alu_op_IN,
	alu_op_OUT,
	wr_enable_IN,
	wr_enable_OUT,
	itype_IN,
	itype_OUT,
	except_IN,
	except_OUT,
	control_type_IN,
	control_type_OUT,
	lui_IN,
	lui_OUT,
	slt_IN,
	slt_OUT,
	byte_load_IN,
	byte_load_OUT,
	word_we_IN,
	word_we_OUT,
	byte_we_IN,
	byte_we_OUT,
	mem_read_IN,
	mem_read_OUT,
	shift_v_IN,
	shift_v_OUT,
	shift_op_IN,
	shift_op_OUT,
	shift_IN,
	shift_OUT,
	load_ra_IN,
	load_ra_OUT,
	link_IN,
	link_OUT,
	alu_b_zero_IN,
	alu_b_zero_OUT,
	branch_control_IN,
	branch_control_OUT,
	jr_IN,
	jr_OUT
);

    input clk, reset, enable, flush;
    input [31:0] alu_out_IN;
    output reg [31:0] alu_out_OUT;
    input [31:0] rt_data_IN;
    output reg [31:0] rt_data_OUT;
    input [4:0] rd_num_IN;
    output reg [4:0] rd_num_OUT;
    input [31:0] link_out_IN;
    output reg [31:0] link_out_OUT;
    input [4:0] rs_num_IN;
    output reg [4:0] rs_num_OUT;
    input [4:0] rt_num_IN;
    output reg [4:0] rt_num_OUT;
    input [2:0] alu_op_IN;
    output reg [2:0] alu_op_OUT;
    input wr_enable_IN;
    output reg wr_enable_OUT;
    input itype_IN;
    output reg itype_OUT;
    input except_IN;
    output reg except_OUT;
    input control_type_IN;
    output reg control_type_OUT;
    input lui_IN;
    output reg lui_OUT;
    input slt_IN;
    output reg slt_OUT;
    input byte_load_IN;
    output reg byte_load_OUT;
    input word_we_IN;
    output reg word_we_OUT;
    input byte_we_IN;
    output reg byte_we_OUT;
    input mem_read_IN;
    output reg mem_read_OUT;
    input shift_v_IN;
    output reg shift_v_OUT;
    input [1:0] shift_op_IN;
    output reg [1:0] shift_op_OUT;
    input shift_IN;
    output reg shift_OUT;
    input load_ra_IN;
    output reg load_ra_OUT;
    input link_IN;
    output reg link_OUT;
    input alu_b_zero_IN;
    output reg alu_b_zero_OUT;
    input [2:0] branch_control_IN;
    output reg [2:0] branch_control_OUT;
    input jr_IN;
    output reg jr_OUT;
    
    always @(posedge clk or posedge reset) begin
        // On reset, clear all registers to zero
        if (reset || flush) begin
            alu_out_OUT <= 32'd0;
            rt_data_OUT <= 32'd0;
            rd_num_OUT <= 5'd0;
            link_out_OUT <= 32'd0;
            rs_num_OUT <= 5'd0;
            rt_num_OUT <= 5'd0;
            alu_op_OUT <= 3'd0;
            wr_enable_OUT <= 1'd0;
            itype_OUT <= 1'd0;
            except_OUT <= 1'd0;
            control_type_OUT <= 1'd0;
            lui_OUT <= 1'd0;
            slt_OUT <= 1'd0;
            byte_load_OUT <= 1'd0;
            word_we_OUT <= 1'd0;
            byte_we_OUT <= 1'd0;
            mem_read_OUT <= 1'd0;
            shift_v_OUT <= 1'd0;
            shift_op_OUT <= 2'd0;
            shift_OUT <= 1'd0;
            load_ra_OUT <= 1'd0;
            link_OUT <= 1'd0;
            alu_b_zero_OUT <= 1'd0;
            branch_control_OUT <= 3'd0;
            jr_OUT <= 1'd0;
        end

        else if (enable) begin
            alu_out_OUT <= alu_out_IN;
            rt_data_OUT <= rt_data_IN;
            rd_num_OUT <= rd_num_IN;
            link_out_OUT <= link_out_IN;
            rs_num_OUT <= rs_num_IN;
            rt_num_OUT <= rt_num_IN;
            alu_op_OUT <= alu_op_IN;
            wr_enable_OUT <= wr_enable_IN;
            itype_OUT <= itype_IN;
            except_OUT <= except_IN;
            control_type_OUT <= control_type_IN;
            lui_OUT <= lui_IN;
            slt_OUT <= slt_IN;
            byte_load_OUT <= byte_load_IN;
            word_we_OUT <= word_we_IN;
            byte_we_OUT <= byte_we_IN;
            mem_read_OUT <= mem_read_IN;
            shift_v_OUT <= shift_v_IN;
            shift_op_OUT <= shift_op_IN;
            shift_OUT <= shift_IN;
            load_ra_OUT <= load_ra_IN;
            link_OUT <= link_IN;
            alu_b_zero_OUT <= alu_b_zero_IN;
            branch_control_OUT <= branch_control_IN;
            jr_OUT <= jr_IN;
        end
    end

endmodule

// Pipeline register 'mem_wb' automatically generated by generate_pipelines.py.
// Used to connect two stages of the pipeline together.
// A list of connected wires is available in generate_pipelines.py
// and the full diagram can be found in pipelined_machine.pdf.
//
// clk - Clock signal. Inputs copy to outputs on rising edge.
// reset - When high, sets all outputs to zeros. Asynchronous
// enable - When high, inputs are copied to outputs on clock edge. When low, outputs remain constant.
// flush - When high, all inputs are set to zero synchronously.
module mem_wb_reg(
    clk,
    reset,
    enable,
    flush,
	alu_out_IN,
	alu_out_OUT,
	data_out_IN,
	data_out_OUT,
	rd_num_IN,
	rd_num_OUT,
	link_out_IN,
	link_out_OUT,
	alu_op_IN,
	alu_op_OUT,
	wr_enable_IN,
	wr_enable_OUT,
	itype_IN,
	itype_OUT,
	except_IN,
	except_OUT,
	control_type_IN,
	control_type_OUT,
	lui_IN,
	lui_OUT,
	slt_IN,
	slt_OUT,
	byte_load_IN,
	byte_load_OUT,
	word_we_IN,
	word_we_OUT,
	byte_we_IN,
	byte_we_OUT,
	mem_read_IN,
	mem_read_OUT,
	shift_v_IN,
	shift_v_OUT,
	shift_op_IN,
	shift_op_OUT,
	shift_IN,
	shift_OUT,
	load_ra_IN,
	load_ra_OUT,
	link_IN,
	link_OUT,
	alu_b_zero_IN,
	alu_b_zero_OUT,
	branch_control_IN,
	branch_control_OUT,
	jr_IN,
	jr_OUT
);

    input clk, reset, enable, flush;
    input [31:0] alu_out_IN;
    output reg [31:0] alu_out_OUT;
    input [31:0] data_out_IN;
    output reg [31:0] data_out_OUT;
    input [4:0] rd_num_IN;
    output reg [4:0] rd_num_OUT;
    input [31:0] link_out_IN;
    output reg [31:0] link_out_OUT;
    input [2:0] alu_op_IN;
    output reg [2:0] alu_op_OUT;
    input wr_enable_IN;
    output reg wr_enable_OUT;
    input itype_IN;
    output reg itype_OUT;
    input except_IN;
    output reg except_OUT;
    input control_type_IN;
    output reg control_type_OUT;
    input lui_IN;
    output reg lui_OUT;
    input slt_IN;
    output reg slt_OUT;
    input byte_load_IN;
    output reg byte_load_OUT;
    input word_we_IN;
    output reg word_we_OUT;
    input byte_we_IN;
    output reg byte_we_OUT;
    input mem_read_IN;
    output reg mem_read_OUT;
    input shift_v_IN;
    output reg shift_v_OUT;
    input [1:0] shift_op_IN;
    output reg [1:0] shift_op_OUT;
    input shift_IN;
    output reg shift_OUT;
    input load_ra_IN;
    output reg load_ra_OUT;
    input link_IN;
    output reg link_OUT;
    input alu_b_zero_IN;
    output reg alu_b_zero_OUT;
    input [2:0] branch_control_IN;
    output reg [2:0] branch_control_OUT;
    input jr_IN;
    output reg jr_OUT;
    
    always @(posedge clk or posedge reset) begin
        // On reset, clear all registers to zero
        if (reset || flush) begin
            alu_out_OUT <= 32'd0;
            data_out_OUT <= 32'd0;
            rd_num_OUT <= 5'd0;
            link_out_OUT <= 32'd0;
            alu_op_OUT <= 3'd0;
            wr_enable_OUT <= 1'd0;
            itype_OUT <= 1'd0;
            except_OUT <= 1'd0;
            control_type_OUT <= 1'd0;
            lui_OUT <= 1'd0;
            slt_OUT <= 1'd0;
            byte_load_OUT <= 1'd0;
            word_we_OUT <= 1'd0;
            byte_we_OUT <= 1'd0;
            mem_read_OUT <= 1'd0;
            shift_v_OUT <= 1'd0;
            shift_op_OUT <= 2'd0;
            shift_OUT <= 1'd0;
            load_ra_OUT <= 1'd0;
            link_OUT <= 1'd0;
            alu_b_zero_OUT <= 1'd0;
            branch_control_OUT <= 3'd0;
            jr_OUT <= 1'd0;
        end

        else if (enable) begin
            alu_out_OUT <= alu_out_IN;
            data_out_OUT <= data_out_IN;
            rd_num_OUT <= rd_num_IN;
            link_out_OUT <= link_out_IN;
            alu_op_OUT <= alu_op_IN;
            wr_enable_OUT <= wr_enable_IN;
            itype_OUT <= itype_IN;
            except_OUT <= except_IN;
            control_type_OUT <= control_type_IN;
            lui_OUT <= lui_IN;
            slt_OUT <= slt_IN;
            byte_load_OUT <= byte_load_IN;
            word_we_OUT <= word_we_IN;
            byte_we_OUT <= byte_we_IN;
            mem_read_OUT <= mem_read_IN;
            shift_v_OUT <= shift_v_IN;
            shift_op_OUT <= shift_op_IN;
            shift_OUT <= shift_IN;
            load_ra_OUT <= load_ra_IN;
            link_OUT <= link_IN;
            alu_b_zero_OUT <= alu_b_zero_IN;
            branch_control_OUT <= branch_control_IN;
            jr_OUT <= jr_IN;
        end
    end

endmodule

